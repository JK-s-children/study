# TCP/IP

앞서 살펴본 OSI 7 계층이 이론과 교육의 목적이었다면, 🔵**일찍이부터 TCP/IP 모델이 실질적으로 사용**되고 있었습니다.

TCP/IP 모델은 4 혹은 5 계층으로 볼 수 있고, 그 중 전송 계층의 TCP 방식에 대해 자세히 알아보려 합니다.

## Packet Switching Network

네트워크 통신은 종착지까지 경로를 지정한 상태로 가지 않습니다. 대신 데이터를 여러 패킷으로 나누고 각 패킷은 다음 목적지마다 최적의 경로를 찾을 수 있도록 합니다. 비연결 방식입니다.

이렇게 나눠서 전송하는 가장 큰 이유는 전자의 방식이라면 중간 경로에 문제가 생겼을때 일체 데이터를 보낼 수 없게 됩니다. 그에 비해 후자의 방식은 이러한 상황에 유연하게 대처할 수 있습니다.

장점만 있는 것은 아닙니다. 🔴**나눠진 패킷들이 독립적으로 전송되므로 순서가 보장되지 않으며 유실될 위험**이 있습니다.

## 연결 지향 프로토콜

네트워크 계층의 IP 방식이 앞서 말한 듯이 비연결이지만, 그 위의 전송 계층의 TCP는 연결 지향 프로토콜입니다.

이것이 어떻게 가능한 것인가 물으면, 물리적으로 연결된 형태가 아닌, 논리적으로 연결 상태처럼 작동하게끔 설계되어 있음을 의미합니다.

🟢**헤더의 제어(ACK, SYN, FIN, …) 및 연결 상태에 대한 정보로 송수신 단계마다 확인하여 연결성을 검증**합니다.

## 연결 설정 3-way handshake

```css
Client        Server
   |----SYN----->|
   |<---SYN-ACK--|
   |----ACK----->|
Connection Established
```

1. 연결을 수행하고자 하는 쪽(클라이언트)에서 SYN(Synchronize sequence numbers)을 요청합니다.
2. 받은 쪽(서버)에서는 그에 대한 확인 ACK(Acknowledgment is valid)과 SYN을 함께 보냅니다.
3. SYN을 받은 클라이언트에서 ACK을 보내면 연결이 성립됩니다.

## 연결 해제 4-way handshake

```css
Client        Server
   |----FIN----->|
   |<----ACK-----|
   |<----FIN-----|
   |----ACK----->|
Connection Terminated
```

1. 연결을 닫고자 하는 쪽(클라이언트)에서 FIN(Terminate the connetion)을 요청합니다.
2. 받은 쪽(서버)에서는 그에 대한 확인 ACK(Acknowledgment is valid)을 보냅니다.
3. 연결 해제를 받은 쪽에서는 패킷을 덜 보냈을 수 도 있기에 다 보낸 후 FIN을 보냅니다.
4. FIN을 받은 클라이언트에서 ACK을 보내면 연결이 종료됩니다.

## 흐름제어

연결이 성립되었다면, 연결 종료까지 패킷을 주고 받아야 합니다.

흐름 제어는 🟢**수신 측의 처리 능력을 초과하지 않도록** 송신 측의 데이터 전송 속도를 조절하는 메커니즘입니다. 이를 통해 데이터 손실을 방지하고 안정적인 통신을 유지합니다.

- **Sliding Window Protocol**:
    - **윈도우 크기**: 수신 측이 처리할 수 있는 데이터 양을 송신 측에 알리는 데 사용됩니다.
    - 수신 측은 자신이 수신 가능한 버퍼 크기를 지속적으로 송신 측에 통보합니다.
    - 송신 측은 이 윈도우 크기를 초과하는 데이터는 전송하지 않습니다.

만일 수신측의 처리 속도가 느리다면, 🟠**보내는 데이터가 헤더의 크기보다 작아져 효율이 떨어질 수** 있습니다.

→ 그때는 어느 정도 🔵**수신측의 버퍼에 공간이 생길 때까지 기다리는 등의 기법**을 사용할 수 있습니다.

## **오류 제어**

오류 제어는 🟢**데이터 전송 중 발생할 수 있는 오류를 탐지하고 복구하는** 메커니즘입니다. 이를 통해 데이터의 무결성을 보장합니다.

- **주요 방법**:
    1. **오류 탐지**: Checksum(검사합) 등을 사용하여 전송된 데이터의 오류 여부를 확인합니다.
    2. **재전송 요청**:
        - **Fast retransmission**: 세번 같은 ACK이 도착한다면 빠르게 재전송을 수행합니다.
        - **Lost Acknowledgment(1)**: 중간의 번호의 ACK을 받지 못했더라도, 다음 ACK을 받았다면 이전 패킷도 무사히 받은 것으로 간주합니다.
        - **Lost Acknowledgment(2):** 받은 패킷을 또 받았다면 즉시 ACK을 보냅니다.
        - 🟠**Lost Acknowledgment의 경우 데드락이 발생하지 않도록 주의해야 합니다.**

## **혼잡 제어**

혼잡 제어는 🟢**네트워크 내에서 과도한 트래픽으로 인해 성능이 저하되는 상황을 방지**하기 위한 메커니즘입니다. 네트워크가 처리 가능한 범위 내에서 데이터 전송 속도를 조절합니다.

- **혼잡 제어 알고리즘**
    1. **Slow Start** (지수적으로 증가, **SS**)
        - 처음에는 전송 속도를 천천히 증가시켜 네트워크의 혼잡 상태를 탐색합니다.
        - Congestion Window(CWND)를 사용하여 전송 데이터의 양을 제어하며, 초기에는 작은 크기로 시작하여 점차적으로 증가합니다.
    2. **Congestion Avoidance** (조금식 증가, **AI**)
        - 처리량이 임계점에 이르면 CWND 증가 속도를 줄여 혼잡을 예방합니다.
    3.  **Recovery** (배수적 감소, **MD**)
        - 혼잡 상황이 발생하면 CWND를 줄여 패킷 손실을 회복하도록 합니다.
        - 시간 초과의 경우 처음부터 **SS**, 3연속 ACK 누락시 **MD** 후 **AI** 수행.

## 소켓 프로그래밍

소켓 자체는 전송 계층(Transport Layer)의 프로토콜(TCP/UDP)을 활용하여 애플리케이션 계층의 통신을 구현하는 **인터페이스**입니다.
