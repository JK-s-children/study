# 4주차 모의 면접 - 자료구조 편

<details>
<summary>[지혜] 빅오 표기법에 대해 설명해 주세요.</summary>

  - 시간 복잡도나 공간 복잡도를 나타내는 표기법으로 알고 있습니다.

**🐒 꼬리 질문 1: 빅오 표기법과 같은 점근 표기법을 사용하는 이유가 뭘까요?**<br>

  - [의도 답안] 시간을 물리적으로 측정하기엔, HW 혹은 OS차이로 실행시간이 날 수 있기 때문에,  시간 복잡도는 “입력에 대한 연산횟수”로 나타낸다.

**🐒 꼬리 질문 2: 자주 사용되는(퀵, 병합) 정렬에 대해 알려주세요**<br>

  - 병합 정렬은 N개의 엘리먼트가 있는 배열을 두 배열로 나누는 걸 반복하며 길이가 1이 될 때까지 반복한 뒤 이들을 정렬하며 병합하는 알고리즘입니다.
  퀵 정렬은 피봇을 정해서 피봇보다 작은 수는 왼쪽, 큰 수는 오른쪽으로 정렬하는 알고리즘입니다.
  시간복잡도는 둘 다 O(N * log(N))이고, 퀵 정렬의 경우 피봇 위치에 따라 최악의 경우 O(N^2)입니다.

**🐒 꼬리 질문 3: 제자리 정렬 관점에서 퀵과 병합 정렬에 대해 말씀해주세요**<br>

  - 병합 정렬은 병합을 수행하기 위해 길이가 N인 배열이 동시에 필요하게 됩니다. 그래서 메모리가 N개 더 필요합니다.
  퀵 정렬의 경우 피봇을 정해서 배열 내에서 병합을 수행하기에 별다른 배열이 필요없는 것으로 알고 있습니다.

  - [보충 설명] 제자리 정렬은 자료구조를 추가로 사용하지 않고 정렬하는 알고리즘입니다.
  병합 정렬의 경우 메모리가 N개 더 필요하기 때문에 제자리 정렬이 아닙니다. 퀵은 제자리 정렬로, 캐시힛 비율이 높습니다.

**🐒 꼬리 질문 4: 만약 10억 개의 데이터를 정렬하는 상황이 있으면 어떻게 해야 할까요?**<br>
  
  - [의도 답안] 메모리 뿐만 아니라 외부 디스크까지 활용하는 외부 병합 정렬(External Merge Sort)를 사용
    - 예를 들어, 900MB의 데이터를 100MB의 RAM을 사용하여 정렬을 해야 한다고 해보자. [출처 링크](https://lovelyunsh.tistory.com/259)
    - 1. 메모리에 읽을 수 있는 100MB 만큼 읽고, 퀵 정렬과 같은 알고리즘으로 정렬 실행
    - 2. 정렬한 1번의 데이터를 디스크에 저장
    - 3. 1, 2번 방법을 9번 반복한다. 그러면 100MB 파일이 9개 생김
    - 4. 9개의 파일에서 각각 처음부터 10MB 씩을 메모리(입력버퍼)에 로딩하고, 10MB의 출력을 위한 버퍼도 만들어둠
    - 5. 9way merge를 수행하고 결과를 출력버퍼에 씀, 이때 출력버퍼가 차면 파일에 쓰고, 출력 버퍼를 비워줌. 9개의 입력 버퍼가 비워지면, 다음 10MB를 읽으며 반복

</details>

<details>
<summary>[병조] 이진 탐색의 원리와 시간복잡도에 대해 설명해 주세요.</summary>

  - 이진탐색은 시작점과 끝점의 중간점을 계속해서 찾아 범위를 줄여가며 탐색하는 알고리즘입니다. 시간 복잡도는 O(log(N)) 입니다.

**🐒 꼬리 질문 1: 파라메트릭 서치에 대해 알고 계신가요?**<br>

  - [의도 답안] 이진탐색과 다르게 주어진 일련의 값들이 아니라 주어진 범위 내에서 원하는 값 또는 원하는 조건에 가장 일치하는 값을 찾아내는 알고리즘입니다.

**🐒 꼬리 질문 2: 배열의 개수 10개일 때, upper bound를 9로 뒀을 때와 10으로 뒀을 때의 차이는 뭘까요?**<br>

  - 실제 원소 인덱스는 0~9 일텐데, Upper Bound가 10인 경우 찾고자 하는 값이 마지막일 때 인덱스 에러가 발생할 것 같습니다.

**🐒 꼬리 질문 3: 해시 테이블의 개념과 해시 테이블 개념을 설명해주세요.**<br>
  
  - 해시 테이블은 해시 함수를 사용해서 키-밸류 형식으로 특정 데이터와 맵핑하여 사용하는 것입니다.
  시간복잡도는 상수 시간을 가집니다. 그러나 충돌이 발생하여 최악의 경우 선형 시간까지 가질 수 있습니다.

**🐒 꼬리 질문 4: 해시 충돌이 발생했을 때 해결하는 방법이 뭐가 있을까요?**<br>

  - 1. 체이닝: 충돌났을 때 값을 리스트로 가지는 것입니다. 그러나 이 경우 리스트 탐색을 해야하니 최악의 경우 O(N)입니다.

  - 2. 오픈 어드레싱: 다른 방법으로 충돌할 때 근처에 값을 할당하는 것입니다. 그러나 이때도 한 곳에 집중하는 클러스터링 현상이 문제가 될 것 같습니다.

  - 3. 이중 해시: 또 다른 방법으로 이중 해시로 해시에서 충돌났을 때 그 다음 지점을 해시로 찾아가는 방식이 있을 것 같습니다.

**🐒 꼬리 질문 5: Swift 컬렉션 타입 중에 해시를 사용한 자료구조에 대해 설명해주세요.**<br>

  - Dictionary와 Set 입니다. Dictionary는 정렬되어 있지 않은 키-밸류 맵핑 자료구조입니다.

**🐒 꼬리 질문 6: Array와 Set은 어떻게 다른가요?**<br>

  - Array는 연속적인 데이터를 저장합니다. 반면, Set은 같은 값이 들어갈 수 없게끔 중복을 방지한 자료구조입니다.

**🐒 꼬리 질문 7: 해시 테이블을 만들 때 제일 중요한 요소가 뭘까요?**<br>

  - 해시 함수의 성능이 가장 중요하다고 생각하며, 이 함수가 얼마나 잘 분산 시키느냐가 중요한 요소라 생각합니다.

**🐒 꼬리 질문 8: 해시 충돌에 대한 해결법으로 말씀해주신 이중 해시 방법에 대한 단점은 없을까요?**<br>

  - [의도 답안] 캐시 효율성이 떨어집니다.

</details>

<details>
<summary>[석영] Swift에서 사용되는 컬렉션 타입 3가지에 대해 설명해주세요.</summary>
  
  - Array, Dictionary, Set이 있습니다.
    - Array: 데이터들을 연속적으로 저장하고, 순서가 있고 중복 저장이 가능합니다.
    - Dictionary: 키-밸류로 저장하고, 순서가 없습니다.
    - Set: Array에 비해 중복 저장이 불가능합니다.

**🐒 꼬리 질문 1: Set, Dictionary를 사용할 때 주의할 점이 있을까요?**<br>

  - 커스텀 타입의 경우 모든 엘리먼트가 기본 요소가 아닌 경우 Hashable을 채택해야 합니다.
  이때 Equatable도 자동으로 채택하게 되는데 따라서 `static func ==` 메소드를 구현해주어 해시 충돌 발생 시 판별을 할 수 있게 합니다.

**🐒 꼬리 질문 2: 배열 관점에서 깊은 복사와 얕은 복사, 그리고 CoW에 대해 아시면 설명해주세요.**<br>

  - 얕은 복사는 최소한의 복사로 새로운 인스턴스 메모리가 생기지 않고 주소값만 공유합니다. 주로 참조 타입에서 사용됩니다.

  - 깊은 복사는 데이터 자체를 복사하는 방법입니다. Array의 경우 값 타입이기 때문에 깊은 복사를 사용합니다.

  - CoW는 생성되어 있는 배열을 다른 변수에 할당해주더라도 쓰기 작업이 일어나기 전에는 깊은 복사를 하지 않고 참조만 하고 있다가 수정이 발생할 경우 그때 깊은 복사를 하는 것입니다.

**🐒 꼬리 질문 3: 하나의 배열에 들어가는 데이터들의 타입은 모두 동일할까요 ?**<br>

  - Any 타입이나 다형성의 경우 다른 타입이 들어갈 수 있을 것 같습니다.

**🐒 꼬리 질문 4: 자료구조에서 배열이랑 리스트는 어떻게 다른가요?**<br>

  - 배열은 연속적으로 할당되고 리스트는 연속적이지 않습니다.

**🐒 꼬리 질문 5: 스택이랑 큐에 대해 설명해주세요.**<br>

  - 스택은 쌓아 올리는 방식, LIFO입니다.
  
  - 큐는 가장 먼저 들어온 원소가 가장 먼저 나가는 FIFO 방식입니다.

**🐒 꼬리 질문 6: 메모리 캐시를 본인이 구현하신다면 어떤 자료구조를 사용하실 건가요?**<br>

  - 캐시 정책에 따라 FIFO를 하냐 LIFO이냐에 따라 다를 것 같습니다. LRU 방식을 사용한다면 스택 방식을 도입해서 구현할 것 같습니다.
  
**🐒 꼬리 질문 7: I/O 관점이 아닌, 캐시에 있는 데이터를 빨리 찾기 위해 탐색에 대한 관점에서 설명해주세요.**<br>

  - [의도 답안] 탐색 관점에서는 균형 트리를 사용하여 구현할 것 같습니다. (B+ 트리)

</details>

<details>
<summary>[효준] 트리와 그래프에 대해 설명해주세요.</summary>

  - 트리는 계층이 있고 부모자식 관계를 가집니다. 반면 그래프는 사이클을 가질 수 있고, 계층이 없습니다.

**🐒 꼬리 질문 1: 트리를 순회하는 방법에 대해 말씀해주세요.**<br>

  - 전위 중위 후위 순회 방법이 있습니다. 루트 노드부터 리프 노드까지 탐색하며 언제 방문할 지에 따라 3가지로 나뉩니다.

**🐒 꼬리 질문 2: 사이클이 있는 그래프에서 순회는 어떻게 하나요?**<br>

  - 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이 있습니다.
    - DFS의 경우 하나의 정점에서 시작하여 그와 관련된 정점을 계속해서 방문해나가는 방식으로, 주로 Stack과 재귀 방식을 이용하여 구현합니다.
    - BFS의 경우 하나의 정점에서 시작하여 방문할 수 있는 모든 정점을 Queue에 넣어 점점 반경을 넓혀가며 순회하는 방식입니다.

**🐒 꼬리 질문 3: 트리로 구현했는데 데이터가 편향될 경우 이를 방지하기 위한 것이 뭐가 있을까요?**<br>

  - 균형 이진 탐색 트리를 사용해서 구현하면 O(log(N))의 탐색 속도를 유지할 수 있을 것 같습니다.
    - 모든 노드에 대해 좌서브 트리의 높이(깊이)와 우서브 트리의 높이의 차가 1을 넘지 않는 **AVL 트리**가 있습니다.

**🐒 꼬리 질문 4: 최소 신장 트리에 대한 알고리즘을 설명해주세요.**<br>

  - 프림 알고리즘과 크루스칼 알고리즘이 있습니다.
    - 프림: 가중치가 있는 무방향 그래프에서 매 순간 최선의 조건을 선택하는 그리디 알고리즘입니다.
    - 크루스칼: 그래프 간선들을 가중치의 오름차순으로 정렬해 놓은 뒤, 사이클을 형성하지 않는 선에서 정렬된 순서대로 간선을 선택합니다.

**🐒 꼬리 질문 5: 트리를 구현할 때 어떤 자료구조를 사용하실 건가요?**<br>

  - 노드를 통해 자기 참조가 가능한 연결리스트를 사용할 것 같습니다. 각 노드는 클래스로 구현하여 레퍼런스 타입으로, 주소만 가진 채 값을 변경하여 부모-자식 관계를 유지할 것 같습니다.

**🐒 꼬리 질문 6: 이진탐색트리에서 어떤 순회를 해야 오름차순된 결과를 얻을 수 있나요?**<br>

  - 중위 순회 입니다.

**🐒 꼬리 질문 7: 동적 프로그래밍에 대해 설명해주세요.**<br>

  - 문제를 잘게 쪼개서 하위부터 문제를 해결하고, 그 계산 결과들을 버리지 않고 재활용하는 메모이제이션 기법 프로그래밍입니다.

</details>

[근영] 일정 이슈