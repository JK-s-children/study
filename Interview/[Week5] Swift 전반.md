# 5주차 모의 면접 - Swift 전반 편

<details>
<summary>[병조] 옵셔널, 구조체와 클래스, Swift Type</summary>

  #### Optional Type
  값이 있을 수도 있고 없을 수도 있는 변수를 표현하는 타입

  #### 옵셔널 클로저가 @escaping을 붙이지 않아도 탈출하는 방식으로 사용 가능한 이유
  옵셔널 클로저는 기본적으로 @escaping으로 간주되어 명시적으로 붙이지 않아도 가능<br>
  언제든지 nil이 될 수 있어 클로저가 스택에 남아있지 않아도 됨.<br>

  #### 옵셔널 바인딩
  옵셔널(?) 타입의 값을 안전하게 언래핑(Unwrapping)하는 방법<br>
  보통 if let과 guard let을 사용하여 구현한다.

  - if let: 특정 블록 내에서만 옵셔널 값을 사용할 때
  - guard let: 불필요한 중첩을 줄이고 값이 없으면 즉시 함수를 종료해야 할 때

  #### 클래스와 구조체의 차이점
  **클래스**
  - 참조 타입
  - 상속 가능
  - 소멸자 사용 가능

  **구조체**
  - 값 타입

  #### 다형성을 제공하는 방법
  다형성: 동일한 인터페이스를 통해 여러 가지 동작을 수행할 수 있도록 하는 개념

  - 상속
  - 프로토콜
  - 오버로딩
  - 오버라이딩

  #### 프로토콜과 상속의 차이
  **프로토콜**
  - 다중 채택 가능
  - 공통 기능을 부여하는 수평적인 구조
  - 수평 관계

  **클래스**
  - 다중 채택 불가능
  - 기존 클래스를 확장하여 재사용하는 구조
  - 수직 관계

  **dynamic dispatch를 막는 방법**
  - final으로 가능

  **mutating 키워드의 역할**

  struct(구조체) 또는 enum(열거형)에서 인스턴스의 속성을 변경할 수 있도록 허용하는 키워드

</details>

<details>
<summary>[석영] 함수와 클로저</summary>

  **클로저란?**

  코드 블록을 변수처럼 저장하고 전달할 수 있는 기능<br>

  **일급 객체**

  함수를 변수나 상수에 저장할 수 있다.<br>
  함수를 다른 함수의 매개변수로 전달하고, 반환 값으로 이용할 수 있다.<br>

  **익명 함수**

  이름이 없는 함수<br>
  Swift에서는 클로저가 익명 함수의 대표적 예시이다.<br>

  **탈출 클로저(@escaping)**

  클로저가 함수의 실행이 끝난 후에도 저장되거나 실행할 수 있는 경우 @escaping이 필요하다.

  **자동 클로저(@autoclosure)**

  표현식을 자동으로 클로저로 감싸서 전달할 수 있다.<br>
  함수 호출 시 {} 없이도 코드 실행을 지연 가능하다.<br>
  단순한 표현식을 지연 실행할 수 있다.<br>

  **캡처 리스트**

  클로저 내부에서 외부 변수를 캡처할 때, 메모리 관리 및 값을 컨트롤하기 위한 방법<br>
  순환 참조 방지에 필수적이다.
  
  **고차 함수**

  다른 함수를 매개변수로 받거나 반환하는 함수<br>
  map, filter, reduce, compactMap, flatMap 등 ...<br>

  **함수형 프로그래밍**

  함수를 일급 객체로 사용하여 프로그래밍하는 방법<br>
  불변성 및 순수 함수를 기반으로 한다.<br>
  불변성으로 인한 상태 변화로 인해 버그가 감소하고, 코드 재사용성이 높아진다.<br>
  구조체의 불변성 특성을 잘 활용할 수 있음.<br>

</details>

<details>
<summary>[효준] 프로토콜과 제네릭</summary>

  **프로토콜이란?**

  특정 역할을 정의하는 인터페이스<br>
  클래스, 구조체, 열거형에서 사용 가능<br>

  **POP**

  프로토콜 중심으로 설계하는 방식<br>
  다중 상속의 단점을 보완하며, 조립식으로 설계<br>

  **DIP**

  SOLID 원칙 중 하나로, 상위 모듈이 하위 모듈에 의존하지 않도록 하는 설계 원칙<br>
  구체적인 구현이 아닌 추상에 의존하게 함<br>

  **연관 타입**
  프로토콜 정의 시 고정된 타입 대신 유연한 타입을 사용할 수 있도록 하기 위해서 사용한다.<br>

</details>

<details>
<summary>[지혜] 동시성</summary>

  **데드락**
  
  두 개 이상의 스레드가 서로의 리소스를 기다리며 영원히 멈춰 있는 상태<br>

  **GCD**

  Swift에서 멀티스레딩을 간편하게 구현할 수 있도록 제공하는 API<br>
  비동기(Asynchronous) 및 동기(Synchronous) 작업을 관리하는 프레임워크<br>
  작업을 큐에 넣고 실행하는 것<br>

  **GCD의 우선순위 역전 문제**
  낮은 우선순위 작업이 높은 우선순위 작업보다 먼저 실행되거나, 높은 우선순위 작업이 대기하는 문제<br>
  GCD에서 qos(Quality of Service) 를 사용하면 작업의 우선순위를 설정할 수 있으나, 낮은 우선순위 작업이 높은 우선순위 작업보다 먼저 실행되는 경우가 발생할 수 있다.<br>
  iOS에서는 lock, semaphore 등의 동기화 객체를 사용할 때 우선순위 상속(QoS Inheritance)이 자동 적용된다. 즉, 낮은 우선순위 작업이 높은 우선순위 작업에 의해 차단되면, 일시적으로 우선순위가 상승하여 빨리 종료된다.<br>

  **스레드 폭발**
  너무 많은 스레드가 생성되어 시스템 리소스를 과도하게 사용하는 현상<br>
  CPU, 메모리 사용량이 급격히 증가하여 성능이 저하되고, 앱이 멈추거나 크래시 발생 가능<br>

  **actor**

  Swift의 actor는 멀티스레딩 환경에서 안전하게 동작할 수 있도록 데이터를 보호하는 개념<br>
  클래스(Class)와 비슷하지만, 내부 상태를 동시 접근으로부터 보호한다.

  **callback 방식의 문제점**
  콜백이 중첩되면서 코드가 깊어지고, 가독성이 떨어진다.<br>
  리턴을 명시할 수 있어 실수를 줄일 수 있다.<br>

</details>
